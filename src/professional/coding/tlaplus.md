# Intro

路上听了一小段TLA+: 通过代数方程描述(indefinite?)状态机. 感觉同函数式编程有些相通: 其中第二节的内容可以重述为: 给定一组方程和当前状态参数x, y, 求解下一状态参数x', y'使得至少一个方程成立, 则由x, y状态进入x', y'状态合法.

indefinite: 与FSM相比, x, y甚至不需要指定"进入下一状态"的方法, 只需要给定一个"判断任意状态是否为合法下一状态"的方法即可. post verification instead of pre instruction.

有趣的是, 视频里Lamport的讲述风格也颇契合TLA+这种"抹去时序, 一视同仁"的思维方式: 为了解释no next state的表达方式而突然思维跳跃地强调equal/assignment的区别; 用同样的力度讲述equation clase这样的重点和conjuction sign在ASCII源码中记为"forward-slash backward-slash"之类无关紧要的细节, 

P.S. Lamport原来还是初代LaTeX的作者. Long live plain text!

# 映射

TLA+中通过函数映射定义'array'和'struct': `r = {Set |-> Value}, Set = 0...42`, ` r = {"name" |-> "the answer", "number"|-> 42}`. 由于是函数映射而非有记忆的内存, 所以只能重定义: `r' = {Set |-> "new value" IF k="target" ELSE r[k]}`. 除了生命修改部分的`r'["target"] = "new value"`, 还必须完整地声名 `r [k] = r[k] for k ~= "target"`: TLA+中直接将状态机的当前状态`r`和下一状态`r'`相联系, 不通过'内存'之类的概念. Structure同理.

这种'笨拙'的做法可能是TLA+的一个核心观念: 状态序列被分解为当前状态和下一状态的彼此约束, 不存在更多的memory/topology. 此前说到的'进入下一状态'和'进入下一状态'的区别, 也可以描述为"由当前状态向下一状态的唯一映射"和"当前状态和下一状态的多对多互相映射"的区别. 由于是多对多的, 描述或求解均可以从任意某一类状态开始.

# 迷宫

想象如何表示一个迷宫: 在纸上划定一个矩形, 选定出口入口, 用一个曲折的通道把他们连接起来, 再添加一些歧路把矩形填满. 我们可以定义每个状态由平面上的一对坐标表示, 用特定的集合约束迷宫的边界, 然后可行的描述思路非常多: 可以是针对每一个坐标, 划定其上下左右是否可及, 也即对于某个具体的`(x, y)`, `(x'=x+1, y'=y), ...`分别是否为合法下一状态; 也可以定一一个集合, 令集合里的每一个状态都可以实现`(x'=x+1, y'=y)`的行为; 也可以定义一个集合, 使集合中的每一个`(x, y)`都可以到达某个特定的坐标`(3, 5)`...它们经过一系列的整理总可以是等价的. 现在假如给迷宫加入各种各样的虫洞, 则需要我们在一些描述里增加方程, 在另一些描述里调整集合. 整个过程中不需要关心玩家如何走迷宫, TLA+只描述要做的是什么.
